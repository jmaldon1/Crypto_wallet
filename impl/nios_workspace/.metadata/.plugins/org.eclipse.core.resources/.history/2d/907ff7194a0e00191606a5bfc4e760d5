/*
 * Company:
 * Author: B. Silver
 *
 * Create Date: 11/25/2018
 * Module Name: wallet_main.c
 * Revision:
 * Description: Main source file
 */

#include "..\Include\wallet_main.h"
#include "..\Include\wallet_status.h"
#include "..\Include\bip39.h"
#include "alt_types.h"
#include "system.h"
#include "altera_avalon_pio_regs.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <tool.h>
#include <chainparams.h>
#include <ecc.h>

static bool showError(const char* er)
{
    printf("Error: %s\n", er);
    btc_ecc_stop();
    return 1;
}

static bool derive_child(const btc_chainparams* chain, char* pkey, char* keypath){
	size_t sizeout = 128;
	char newextkey[sizeout];

	//check if we derive a range of keys
	unsigned int maxlen = 1024;
	int posanum = -1;
	int posbnum = -1;
	int end = -1;
	uint64_t from;
	uint64_t to;

	static char digits[] = "0123456789";
	for (unsigned int i = 0; i<strlen(keypath); i++) {
		if (i > maxlen) {
			break;
		}
		if (posanum > -1 && posbnum == -1) {
			if (keypath[i] == '-') {
				if (i-posanum >= 9) {
					break;
				}
				posbnum = i+1;
				char buf[9] = {0};
				memcpy (buf, &keypath[posanum], i-posanum);
				from = strtoull(buf, NULL, 10);
			}
			else if (!strchr(digits, keypath[i])) {
				posanum = -1;
				break;
			}
		}
		else if (posanum > -1 && posbnum > -1) {
			if (keypath[i] == ']' || keypath[i] == ')') {
				if (i-posbnum >= 9) {
					break;
				}
				char buf[9] = {0};
				memcpy (buf, &keypath[posbnum], i-posbnum);
				to = strtoull(buf, NULL, 10);
				end = i+1;
				break;
			}
			else if (!strchr(digits, keypath[i])) {
				posbnum = -1;
				posanum = -1;
				break;
			}
		}
		if (keypath[i] == '[' || keypath[i] == '(') {
			posanum = i+1;
		}
	}

	if (end > -1 && from <= to) {
		for (uint64_t i = from; i <= to; i++) {
			char keypathnew[strlen(keypath)+16];
			memcpy(keypathnew, keypath, posanum-1);
			char index[9] = {0};
			sprintf(index, "%lld", i);
			memcpy(keypathnew+posanum-1, index, strlen(index));
			memcpy(keypathnew+posanum-1+strlen(index), &keypath[end], strlen(keypath)-end);


			if (!hd_derive(chain, pkey, keypathnew, newextkey, sizeout))
				return showError("Deriving child key failed\n");
			else
				hd_print_node(chain, newextkey);
		}
	}
	else {
		if (!hd_derive(chain, pkey, keypath, newextkey, sizeout))
			return showError("Deriving child key failed\n");
		else
			hd_print_node(chain, newextkey);
	}

	btc_ecc_stop();
	return 1;
}


int main()
{
	printf("Hello World from NIOS II\n");
	printf("Software Version: %d.%d.%d\n\n", SOFTWARE_VERSION_MAJOR, SOFTWARE_VERSION_MINOR, SOFTWARE_VERSION_REV);

	void *lots_of_memory = malloc(1024 * 1024 * 10);	// attempt to allocate 10MB
    printf("SDRAM malloc returned 0x%08lx\n", (alt_u32)lots_of_memory);

    char* keypath = "m/44h/0h/0h/0/0";
//    uint8_t seed[64];
//
//    const char *mnemonic_phrase = mnemonic_generate(128);
//    printf("MNEMONIC PHRASE: %s", mnemonic_phrase);

    btc_ecc_start();

    const btc_chainparams* chain = &btc_chainparams_test;
    size_t sizeout = 128;
    char masterkey[sizeout];
    hd_gen_master(chain, masterkey, sizeout);
    printf("masterkey: %s\n", masterkey);

    hd_print_node(chain, masterkey);

    derive_child(chain, masterkey, keypath);



//    mnemonic_to_seed(mnemonic_phrase, "TEST", seed, 0);
////
//	printf("Seed: ");
//	for(int i = 0; i < 64; i++){
//		printf("%x", seed[i]);
//	}
//	printf("\n");
//
//
    int count = 0;
    int delay;

    // main loop
    while(1)
    {
        IOWR_ALTERA_AVALON_PIO_DATA(PO_LED_BASE, count & 0xFF);
        delay = 0;
        while(delay < 200000)
        {
            delay++;
        }
        count++;
    }

	return 0;
}
